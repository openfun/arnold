# Concepts

In this section, we will define every word and concept that we will be dealing
with in the code and the documentation of the project.

## Customers and environments

What we call a customer is more or less an hosted instance of Open edX.

A customer instance can be installed in several environments. We currently
defined four different ones:

* **feature**: one environment for each feature branch, the feature being
  described by its title (**e.g** `feat/99-change-background-color`),
* **staging**: aggregating all features before a release,
* **preprod**: validating a release before going live,
* **production**: customer facing operations.

In order to deploy our applications, we need to generate configuration files
customized for each project, being defined by a customer site AND an
environment.

## Project and application names

A project name is used for `OpenShift` projects and it is generated using the
following pattern:

    {{ environment }}-{{ customer }}[--{{ feature_title }}]

The application name is generated using the following pattern:

    {{ environment }}-{{ customer }}-{{ application }}[--{{ feature_title }}]

where:

* `environment`: the name of the environment (feature, staging, preprod or prod)
* `customer`: the one-word name of the customer site (fun, campus, corporate,
  ademe, etc.)
* `application`: the one-word name of the application (lms, cms, etc.)
* `feature_title`: the slugified title of the feature. Only applicable when the
  `environment` is equal to `feature`.

The application name is used as a subdomain of the `domain_name` defined in
`group_vars/all/openshift_routes.yml` (_e.g._ `example.com`) to compose urls,
except for production environments where urls are set to the customer's domain.

Here are some examples of valid urls on the `example.com` platform:

* staging-campus-cms.example.com
* staging-campus-lms.example.com
* preprod-fun-lms.example.com
* feature-coporate-lms--change-background-color-on-contact-form.example.com

All these development urls are protected by basic authentication. For this
purpose, an `htpasswd` file is generated in the `nginx` container upon startup:

* the login is set to the one-word customer name,
* the password is an auto-generated secret (see below),
* the login and password are used to generate the `htpasswd` file upon startup
  of the `nginx` container,
* the login and password are sent to the customer by email and posted in a
  dedicated `#deploy` Slack channel.

## Configuration

We use OpenShift's `Configmap`s and `Secret`s for our applications' settings and
services configurations.

Credentials are stored as flat yaml encrypted files so that they can simply be
committed in `Arnold`'s repository.

The credential files are encrypted with `ansible-vault` and the vault password
specific to each project is recorded as an `OpenShift` secret while creating the
project:

```yaml
secretKeyRef:
  name: vaultpass
  key: vaultpass
```

When deploying an application that requires credentials:

* the encrypted file is decrypted by the Ansible vault,
* an OpenShift's `Secret` is then generated from those variables definitions,
* this secret is mounted by an `initContainer` in a configuration volume shared
  with the application container or directly injected in the application
  container as environment variables.

We must distinguish two types of credentials:

### 1. Auto-generated secrets

> _This feature is not yet implemented_

These secrets are login/passwords or tokens that are auto-generated by `Arnold`
(see details below).

> The `DJANGO_SECRET_KEY` or `MYSQL_PASSWORD` settings are examples of
> auto-generated secrets.

### 2. Third-party credentials

These credentials are login/passwords or tokens given by third party SaaS
applications. They are known by the development team who subscribed to the
service and added them to the credentials file.

> The `GOOGLE_ANALYTICS_ID` or `SENTRY_DSN` settings are examples of third-party
> credentials.

## Adding a customer site

A customer site is defined by a set of files in three places:

* `group_vars/customer/`: a yaml file bearing the name of the customer, in which
  are defined all the variables that are injected in the Jinja templates to
  generate OpenShift's `Configmaps` and description files adapted for the
  customer,
* `group_vars/secret`: a folder bearing the name of the customer and containing
  a `credentials.vault.yml` vaulted file for each environment,
* `files/configmap/`: an optional folder bearing the name of the customer and
  containing one (or more) `ConfigMap` for each environment, with files specific
  to the customer. These `ConfigMap`s are assembled with the `Configmap`s
  generated from the default templates (see `templates/configmap`) and might
  override them if they redefine the same file for the same application.

The following tasks are necessary to add a new customer in `Arnold`:

* create new projects in `OpenShift` for each environment,
* add a yaml file in `group_vars/customer/` with all customer-specific variables
  or overrides,
* add a directory in `group_vars/secret/` with the directory structure for each
  environment:
  * generate secrets,
  * set third-party credentials in a `credentials.vault.yml` file.
* optionally add a directory in `files/configmap/` to add or override default
  `ConfigMap`s,
* create new databases in the target infrastructure using the auto-generated
  secrets,
* generate vault passwords for each infrastructure:
  * use the vault passwords to encrypt all credential files in the repository,
  * record each vault password as a secret in the corresponding project in
    `OpenShift`,
  * display vault passwords for all environments once in the console so the
    developer can save them in a password manager.

These tasks will be automated in a near future in a `add_customer` playbook.
After running this playbook, the developer will be invited to manually:

* customize variables and files as necessary,
* commit everything to the repository.
