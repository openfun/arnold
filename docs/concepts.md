# Arnold's

Arnold's is the place where all FUN's applications are assembled and deployed to `OpenShift` as `Docker` services.

A customer site is installed in several environments:
  * **feature:** one environment for each feature branch, the feature being described by its title (**e.g** feat/99-change-background-color),
  * **staging:** aggregating all features before a release,
  * **preprod:** validating a release before going live,
  * **production:** customer facing operations.

In order to deploy our applications, we need to generate configuration files customized for each project, being defined by a customer site AND an environment.


# Project and app names

The project name is used for `OpenShift` projects and is generated using the following pattern::

    {{ environment }}-{{ customer }}[--{{ feature_name }}]

The application name is generated using the following pattern:

    {{ environment }}-{{ customer }}-{{ application }}[--{{ feature_name }}]

Where:

- **environment:** the name of the environment (feature, staging, preprod or prod)
- **customer:** the one-word name of the customer site (fun, campus, corporate, ademe, etc.)
- **application:** the one-word name of the application (lms, cms, etc.)
- **feature_title:** the slugified title of the feature. Only applicable when the `environment` is equal to `feature`.

The application name is used as a subdomain of `dev.openfun.fr` to compose urls, except for production environments where urls are set to the customer's domain.

Here are some examples of valid urls on the `dev.openfun.fr` platform:

- staging-campus-cms.dev.openfun.fr
- staging-campus-lms.dev.openfun.fr
- preprod-fun-lms.dev.openfun.fr
- feature-coporate-lms--change-background-color-on-contact-form.dev.openfun.fr

All these development urls are protected by basic authentication. For this purpose, an `htpasswd` file is generated in the `nginx` container upon startup:

- the login is set to the one-word customer name,
- the password is an auto-generated secret (see below),
- the login and password are used to generate the `htpasswd` file upon startup of the `nginx` container,
- the login and password are sent to the customer by email and posted in a dedicated `#deploy` Slack channel.


# Configuration

We use `OpenShift`'s Configmaps for our applications' settings and secret credentials.

Credentials are stored as encrypted files in Configmaps and not as `OpenShift` secrets so that they
can simply be committed in `Arnold`'s repository.

The credential files are encrypted with `Ansible Vault` and the vault password specific to each
project is recorded as an `OpenShift` secret while creating the project:

    secretKeyRef:
      name: vaultpass
      key: vaultpass

When deploying an application that requires credentials:

- the encrypted file is decrypted by an init container in `OpenShift`,
- the init container runs Arnold's `Docker` image to benefit from the same `Ansible` environment,
- once decrypted, the file is placed by the init container in a config volume shared with the
  application container.

We must distinguish two types of credentials:

## 1. Auto-generated secrets

These secrets are login/passwords or tokens that are auto-generated by `Arnold` (see details below).

The `DJANGO_SECRET_KEY` or `MYSQL_PASSWORD` settings are examples of auto-generated secrets.

## 2. Third-party credentials

These credentials are login/passwords or tokens given by third party SaaS applications. They are
known by the development team who subscribed to the service and added them to the credentials file.

The `GOOGLE_ANALYTICS_ID` or `SENTRY_DSN` settings are examples of third-party credentials.


# Quick start

Arnold's Ansible playbooks are best run with `Docker`.

Make sure you have a recent version of `Docker` installed on your laptop:

    $ docker -v
      Docker version 17.12.0-ce, build c97c6d6

And build Arnold's `Docker` image:

```bash
$ cd path/to/cloned/repository
$ docker build -t arnold:$(tr -d '\n' < VERSION) .
```

To login to OpenShift, you also need a recent version of the `oc` client
installed:

    $ oc version
      oc v3.9.0-alpha.3+78ddc10
      kubernetes v1.9.1+a0ce1bc657
      features: Basic-Auth GSSAPI Kerberos SPNEGO

      Server https://console.dev.openfun.fr:8443
      openshift v3.7.1+c2ce2c0-1
      kubernetes v1.7.6+a08f5eeb62

> You can download a recent `oc` release from the [releases
> page](https://github.com/openshift/origin/releases) of the project's GitHub
> repository. Once downloaded, untar the archive and copy the `oc` binary
> somewhere in your `$PATH` (_e.g._ `$HOME/bin`). Alternatively, if you plan to
> work on the project with [MiniShift](https://github.com/MiniShift/MiniShift),
> please refer to [our installation procedure](./docs/MiniShift.md).

And login to OpenShift:

    $ oc login https://console.dev.openfun.fr:8443 --username=fun --password=xxxxx

> If you are asked to use an "insecure connection" (because "the server uses a
> certificate signed by an unknown authority") and you are running on our
> OpenShift's pre-production instance (as the example URL above), you can safely
> accept.

## Adding a customer site

A customer site is defined by a set of files in two places:

- **`group_vars/customer/`:** a yaml file bearing the name of the customer, in which are defined all
  the variables that are injected in the Jinja templates to generate `OpenShift` Configmaps and
  description files adapted for the customer,
- **`files/configmap/`:** a folder bearing the name of the customer and containing a Configmap for
  each environment, with files specific to the customer. These files are assembled with the
  Configmap files generated from the templates and might override them if they redefine the same
  file for the same application.

The following tasks are necessary to add a new customer in `Arnold`:

- create new projects in `OpenShift` for each environment,
- add a yaml file in `group_vars/customer/` with all variables,
- add a directory in `files/configmap/` with the directory structure for each environment:
    * generate secrets,
    * set third-party credentials.
- create new databases in the target infrastructure using the auto-generated secrets,
- generate vault passwords for each infrastructure:
    * use the vault passwords to encrypt all credential files in the repository,
    * record each vault password as a secret in the corresponding project in `OpenShift`,
    * display vault passwords for all environments once in the console so the developer can save them in a password manager.

These tasks are automated in the `add_customer` playbook:

    $ docker run -it -v $PWD:/app -u $(id -u):$(id -g) -e ANSIBLE_VAULT_PASS=xxxxx -e K8S_AUTH_API_KEY=$(oc whoami -t) -e K8S_AUTH_HOST=https://console.dev.openfun.fr:8443 arnold:$(tr -d '\n' < VERSION) ansible-playbook add_customer.yml -e "customer=corporate"

After running the playbook, the developer should manually:

- customize variables and files as necessary,
- commit everything to the repository.

## Create new project

To create a new project in `OpenShift`, run:

    $ docker run -it -v $PWD:/app -u $(id -u):$(id -g) -e ANSIBLE_VAULT_PASS=xxxxx -e K8S_AUTH_API_KEY=$(oc whoami -t) -e K8S_AUTH_HOST=https://console.dev.openfun.fr:8443 arnold:$(tr -d '\n' < VERSION) ansible-playbook create_project.yml -e "customer=corporate env_type=preprod"

### Development

In development with MiniShift you can use the helper script:

    $ bin/ansible-playbook create_project.yml -e "env_type=development"

## Generating the Configmaps

To generate the Configmaps and synchronize them with `OpenShift`, run:

    $ docker run -it -v $PWD:/app -u $(id -u):$(id -g) -e ANSIBLE_VAULT_PASS=xxxxx -e K8S_AUTH_API_KEY=$(oc whoami -t) -e K8S_AUTH_HOST=https://console.dev.openfun.fr:8443 arnold:$(tr -d '\n' < VERSION) ansible-playbook create_config.yml -e "customer=corporate env_type=preprod"

The default env_type is `staging`.
The default customer is `patient0`, a demo site with default configuration.

### Development

In development with MiniShift you can use the helper script:

    $ bin/ansible-playbook create_config.yml -e "env_type=development"

## Deploying the applications

The deployment files are compiled by injecting project variables in a set of `Ansible` templates and sent to `OpenShift` using Ansible's `openshit_raw` module.

To synchronize the deployment files with `OpenShift`, run:

    $  docker run -it -v $PWD:/app -u $(id -u):$(id -g) -e ANSIBLE_VAULT_PASS=xxxxx -e K8S_AUTH_API_KEY=$(oc whoami -t) -e K8S_AUTH_HOST=https://console.dev.openfun.fr:8443 arnold:$(tr -d '\n' < VERSION) ansible-playbook deploy.yml -e "customer=corporate env_type=preprod"

For a `feature` environment, you should also set a `feature_title` variable with a slug describing the feature:

    .../... ansible-playbook deploy.yml -e "env_type=feature feature_title=change-background-color"

The corresponding objects should now be available in `OpenShift`.

### Development

In development with MiniShift you can use the helper script:

    $ bin/ansible-playbook deploy.yml -e "env_type=development"

# Developers documentations

* [Configuring MiniShift](./docs/minishift.md)
* [Naming convention](./docs/naming_conventions.md)
* [Routes aliases](./docs/routes_aliases.md)
* [Customers app](./docs/customers.md)
